/**
 * Syscoin API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class OffersApi {
    protected basePath = 'http://localhost:8001';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * 
     * Accept&amp;Pay for a confirmed offer.
     * @param request 
     */
    public offeraccept(request: models.OfferAcceptRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offeracceptWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * Acknowledge offer payment as seller of offer. Deducts qty of offer and increases number of sold inventory.
     * @param offerguid 
     * @param offeracceptguid 
     */
    public offeracceptacknowledge(offerguid: string, offeracceptguid: string, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offeracceptacknowledgeWithHttpInfo(offerguid, offeracceptguid, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * Send feedback and rating for offer accept specified. Ratings are numbers from 1 to 5
     * @param offerguid 
     * @param offeracceptguid 
     * @param feedback 
     * @param rating 
     */
    public offeracceptfeedback(offerguid: string, offeracceptguid: string, feedback?: string, rating?: number, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offeracceptfeedbackWithHttpInfo(offerguid, offeracceptguid, feedback, rating, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * list my offer accepts
     * @param aliases 
     * @param acceptguid 
     * @param privatekey 
     */
    public offeracceptlist(aliases?: Array<string>, acceptguid?: string, privatekey?: string, extraHttpRequestParams?: any): Observable<Array<models.OfferAccept>> {
        return this.offeracceptlistWithHttpInfo(aliases, acceptguid, privatekey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * Add to the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offeraddwhitelist(request: models.OfferAddWhitelistRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offeraddwhitelistWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * Clear the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerclearwhitelist(request: models.OfferClearWhitelistRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offerclearwhitelistWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * scan and filter offers
     * @param regexp apply [regexp] on offeres, empty means all offeres
     * @param from show results from number [from]
     * @param safesearch shows all offers that are safe to display (not on the ban list)
     * @param category Category you want to search in, empty for all
     */
    public offerfilter(regexp: string, from?: number, safesearch?: string, category?: string, extraHttpRequestParams?: any): Observable<Array<models.Offer>> {
        return this.offerfilterWithHttpInfo(regexp, from, safesearch, category, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * List all stored values of an offer.
     * @param offer Offer GUID.
     */
    public offerhistory(offer: string, extraHttpRequestParams?: any): Observable<Array<models.OfferHistoryEntry>> {
        return this.offerhistoryWithHttpInfo(offer, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * Show values of an offer.
     * @param guid 
     */
    public offerinfo(guid: string, extraHttpRequestParams?: any): Observable<models.Offer> {
        return this.offerinfoWithHttpInfo(guid, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerlink(request: models.OfferLinkRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offerlinkWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * List offers that an array of aliases own. Set of aliases to look up based on alias, and private key to decrypt any data found in offer.
     * @param aliases 
     * @param offer 
     * @param privatekey 
     */
    public offerlist(aliases?: Array<string>, offer?: string, privatekey?: string, extraHttpRequestParams?: any): Observable<Array<models.Offer>> {
        return this.offerlistWithHttpInfo(aliases, offer, privatekey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * Create a new offer on the Syscoin decentralized marketplace. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offernew(request: models.OfferNewRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offernewWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * Remove from the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerremovewhitelist(request: models.OfferRemoveWhitelistRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offerremovewhitelistWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * Perform an update on an offer you control. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerupdate(request: models.OfferUpdateRequest, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.offerupdateWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * 
     * List all affiliates for this offer.
     * @param offerguid 
     */
    public offerwhitelist(offerguid: string, extraHttpRequestParams?: any): Observable<Array<models.OfferWhitelistEntry>> {
        return this.offerwhitelistWithHttpInfo(offerguid, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * 
     * Accept&amp;Pay for a confirmed offer.
     * @param request 
     */
    public offeracceptWithHttpInfo(request: models.OfferAcceptRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offeraccept`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offeraccept.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Acknowledge offer payment as seller of offer. Deducts qty of offer and increases number of sold inventory.
     * @param offerguid 
     * @param offeracceptguid 
     */
    public offeracceptacknowledgeWithHttpInfo(offerguid: string, offeracceptguid: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offeracceptacknowledge`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'offerguid' is not null or undefined
        if (offerguid === null || offerguid === undefined) {
            throw new Error('Required parameter offerguid was null or undefined when calling offeracceptacknowledge.');
        }
        // verify required parameter 'offeracceptguid' is not null or undefined
        if (offeracceptguid === null || offeracceptguid === undefined) {
            throw new Error('Required parameter offeracceptguid was null or undefined when calling offeracceptacknowledge.');
        }
        if (offerguid !== undefined) {
            if(offerguid instanceof Date) {
                queryParameters.set('offerguid', <any>offerguid.d.toISOString());
            } else {
                queryParameters.set('offerguid', <any>offerguid);
            }
        }

        if (offeracceptguid !== undefined) {
            if(offeracceptguid instanceof Date) {
                queryParameters.set('offeracceptguid', <any>offeracceptguid.d.toISOString());
            } else {
                queryParameters.set('offeracceptguid', <any>offeracceptguid);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Send feedback and rating for offer accept specified. Ratings are numbers from 1 to 5
     * @param offerguid 
     * @param offeracceptguid 
     * @param feedback 
     * @param rating 
     */
    public offeracceptfeedbackWithHttpInfo(offerguid: string, offeracceptguid: string, feedback?: string, rating?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offeracceptfeedback`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'offerguid' is not null or undefined
        if (offerguid === null || offerguid === undefined) {
            throw new Error('Required parameter offerguid was null or undefined when calling offeracceptfeedback.');
        }
        // verify required parameter 'offeracceptguid' is not null or undefined
        if (offeracceptguid === null || offeracceptguid === undefined) {
            throw new Error('Required parameter offeracceptguid was null or undefined when calling offeracceptfeedback.');
        }
        if (offerguid !== undefined) {
            if(offerguid instanceof Date) {
                queryParameters.set('offerguid', <any>offerguid.d.toISOString());
            } else {
                queryParameters.set('offerguid', <any>offerguid);
            }
        }

        if (offeracceptguid !== undefined) {
            if(offeracceptguid instanceof Date) {
                queryParameters.set('offeracceptguid', <any>offeracceptguid.d.toISOString());
            } else {
                queryParameters.set('offeracceptguid', <any>offeracceptguid);
            }
        }

        if (feedback !== undefined) {
            if(feedback instanceof Date) {
                queryParameters.set('feedback', <any>feedback.d.toISOString());
            } else {
                queryParameters.set('feedback', <any>feedback);
            }
        }

        if (rating !== undefined) {
            if(rating instanceof Date) {
                queryParameters.set('rating', <any>rating.d.toISOString());
            } else {
                queryParameters.set('rating', <any>rating);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * list my offer accepts
     * @param aliases 
     * @param acceptguid 
     * @param privatekey 
     */
    public offeracceptlistWithHttpInfo(aliases?: Array<string>, acceptguid?: string, privatekey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offeracceptlist`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (aliases) {
            queryParameters.set('aliases', aliases.join(COLLECTION_FORMATS['csv']));
        }

        if (acceptguid !== undefined) {
            if(acceptguid instanceof Date) {
                queryParameters.set('acceptguid', <any>acceptguid.d.toISOString());
            } else {
                queryParameters.set('acceptguid', <any>acceptguid);
            }
        }

        if (privatekey !== undefined) {
            if(privatekey instanceof Date) {
                queryParameters.set('privatekey', <any>privatekey.d.toISOString());
            } else {
                queryParameters.set('privatekey', <any>privatekey);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Add to the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offeraddwhitelistWithHttpInfo(request: models.OfferAddWhitelistRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offeraddwhitelist`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offeraddwhitelist.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Clear the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerclearwhitelistWithHttpInfo(request: models.OfferClearWhitelistRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offerclearwhitelist`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerclearwhitelist.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * scan and filter offers
     * @param regexp apply [regexp] on offeres, empty means all offeres
     * @param from show results from number [from]
     * @param safesearch shows all offers that are safe to display (not on the ban list)
     * @param category Category you want to search in, empty for all
     */
    public offerfilterWithHttpInfo(regexp: string, from?: number, safesearch?: string, category?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offerfilter`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'regexp' is not null or undefined
        if (regexp === null || regexp === undefined) {
            throw new Error('Required parameter regexp was null or undefined when calling offerfilter.');
        }
        if (regexp !== undefined) {
            if(regexp instanceof Date) {
                queryParameters.set('regexp', <any>regexp.d.toISOString());
            } else {
                queryParameters.set('regexp', <any>regexp);
            }
        }

        if (from !== undefined) {
            if(from instanceof Date) {
                queryParameters.set('from', <any>from.d.toISOString());
            } else {
                queryParameters.set('from', <any>from);
            }
        }

        if (safesearch !== undefined) {
            if(safesearch instanceof Date) {
                queryParameters.set('safesearch', <any>safesearch.d.toISOString());
            } else {
                queryParameters.set('safesearch', <any>safesearch);
            }
        }

        if (category !== undefined) {
            if(category instanceof Date) {
                queryParameters.set('category', <any>category.d.toISOString());
            } else {
                queryParameters.set('category', <any>category);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * List all stored values of an offer.
     * @param offer Offer GUID.
     */
    public offerhistoryWithHttpInfo(offer: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offerhistory`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'offer' is not null or undefined
        if (offer === null || offer === undefined) {
            throw new Error('Required parameter offer was null or undefined when calling offerhistory.');
        }
        if (offer !== undefined) {
            if(offer instanceof Date) {
                queryParameters.set('offer', <any>offer.d.toISOString());
            } else {
                queryParameters.set('offer', <any>offer);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Show values of an offer.
     * @param guid 
     */
    public offerinfoWithHttpInfo(guid: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offerinfo`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'guid' is not null or undefined
        if (guid === null || guid === undefined) {
            throw new Error('Required parameter guid was null or undefined when calling offerinfo.');
        }
        if (guid !== undefined) {
            if(guid instanceof Date) {
                queryParameters.set('guid', <any>guid.d.toISOString());
            } else {
                queryParameters.set('guid', <any>guid);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerlinkWithHttpInfo(request: models.OfferLinkRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offerlink`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerlink.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * List offers that an array of aliases own. Set of aliases to look up based on alias, and private key to decrypt any data found in offer.
     * @param aliases 
     * @param offer 
     * @param privatekey 
     */
    public offerlistWithHttpInfo(aliases?: Array<string>, offer?: string, privatekey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offerlist`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (aliases) {
            queryParameters.set('aliases', aliases.join(COLLECTION_FORMATS['csv']));
        }

        if (offer !== undefined) {
            if(offer instanceof Date) {
                queryParameters.set('offer', <any>offer.d.toISOString());
            } else {
                queryParameters.set('offer', <any>offer);
            }
        }

        if (privatekey !== undefined) {
            if(privatekey instanceof Date) {
                queryParameters.set('privatekey', <any>privatekey.d.toISOString());
            } else {
                queryParameters.set('privatekey', <any>privatekey);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Create a new offer on the Syscoin decentralized marketplace. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offernewWithHttpInfo(request: models.OfferNewRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offernew`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offernew.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Remove from the affiliate list of your offer(controls who can resell). Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerremovewhitelistWithHttpInfo(request: models.OfferRemoveWhitelistRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offerremovewhitelist`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerremovewhitelist.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Perform an update on an offer you control. Requires wallet passphrase to be set with walletpassphrase call.
     * @param request 
     */
    public offerupdateWithHttpInfo(request: models.OfferUpdateRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offerupdate`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling offerupdate.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * List all affiliates for this offer.
     * @param offerguid 
     */
    public offerwhitelistWithHttpInfo(offerguid: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/offerwhitelist`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'offerguid' is not null or undefined
        if (offerguid === null || offerguid === undefined) {
            throw new Error('Required parameter offerguid was null or undefined when calling offerwhitelist.');
        }
        if (offerguid !== undefined) {
            if(offerguid instanceof Date) {
                queryParameters.set('offerguid', <any>offerguid.d.toISOString());
            } else {
                queryParameters.set('offerguid', <any>offerguid);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (token) required
        if (this.configuration.apiKey) {
            headers.set('token', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
